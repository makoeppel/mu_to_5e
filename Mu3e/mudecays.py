import numpy as np
from phasespace import GenParticle
from particle import literals as lp  # --> MeV units
import hepunits as u  # converting to GeV

import os

this_dir = os.path.dirname(os.path.realpath(__file__))

from . import fastmc as fm

# import the amplitude model from each process:
from .mu1e2nu.SubProcesses.P1_mup_vmxveep_no_zh import matrix2py as amp_mu1e2nu
from .mu3e2nu.SubProcesses.P1_mup_vmxveepepem_no_zh import matrix2py as amp_mu3e2nu
from .mu5e2nu.SubProcesses.P1_mup_vmxveepepemepem_no_zh import matrix2py as amp_mu5e2nu


def mu_PS(x):
    return 1 - 8 * x - 12 * x**2 * np.log(x) + 8 * x**3 - x**4


Gamma_mu = (
    (1.16e-5 / u.GeV**2) ** 2
    * (lp.mu_minus.mass / u.MeV) ** 5
    / (192 * np.pi**3)
    * mu_PS((lp.e_minus.mass / lp.mu_minus.mass) ** 2)
)


# Results from MadGraph run:
# 3e2nu seem ok! -- BR ~ 3.6e-5 # from https://arxiv.org/pdf/1811.10965.pdf
BR_mu3e2nu = (1.155e-20 / u.MeV) / (Gamma_mu / u.MeV)
# 5e2nu -- no known resul in literature
BR_mu5e2nu = (1.342e-25 / u.MeV) / (Gamma_mu / u.MeV)


CHANNELS = ["mu1e2nu", "mu3e2nu", "mu5e2nu", "mu5e"]
BRANCHINGS = [1.0, BR_mu3e2nu, BR_mu5e2nu, None]
AMPLITUDES = [amp_mu1e2nu, amp_mu3e2nu, amp_mu5e2nu, None]
CHANNEL_LATEX_NAMES = [
    r"$\mu^+ \to e^+ \nu_e \overline{\nu}_\mu$",
    r"$\mu^+ \to e^+ e^+e^- \nu_e \overline{\nu}_\mu$",
    r"$\mu^+ \to e^+ e^+e^- e^+e^- \nu_e \overline{\nu}_\mu$",
    r"$\mu^+ \to e^+ e^+e^- e^+e^-$",
]

AMP_DICT = {c: a for c, a in zip(CHANNELS, AMPLITUDES)}
BR_DICT = {c: a for c, a in zip(CHANNELS, BRANCHINGS)}
LATEX_NAMES_DICT = {c: a for c, a in zip(CHANNELS, CHANNEL_LATEX_NAMES)}


class Process:
    """
    Class to store the events generated by `phasespace`
    """

    def __init__(self, channel, model=None, n_events=1000):
        """
        Initialize the class and put format the momenta correctly
        """

        if channel not in CHANNELS:
            raise ValueError(
                f"Channel {channel} not recognized. Choose from {CHANNELS}"
            )
        elif channel == "mu5e" and model is None:
            raise ValueError(f"Channel {channel} requires a model to be specified.")
        else:
            self.channel = channel
            self.model = model

        self.n_events = n_events

        self.amp = AMP_DICT[self.channel]
        self.branching = BR_DICT[self.channel]
        self.latex_name = LATEX_NAMES_DICT[self.channel]
        self.n_tracks = int(self.channel[2])
        # If new physics, then calculate it from model class
        if self.channel == "mu5e":
            self.branching = self.model.get_mu5e_BR()

    def initialize_amplitude(self):
        if self.channel != "mu5e":
            self._param_card = f"{this_dir}/{self.channel}/Cards/param_card.dat"
            if not os.path.isfile(self._param_card) and self.amp:
                raise ValueError(
                    f"Param card {self._param_card} for MG5 amplitude not found."
                )

            # amplitude module (already model initialised) from MG@5
            self.alphaS = 0.12  # alpha strong -- not relevant for us.
            self.nhel = 0  # summ over all helicites -- TODO include helicities?

            # model module from MG@5
            try:
                self.amp.initialisemodel(self._param_card)
            except AttributeError:
                print("Model could not be initialized.")

    def generate(self):
        # ------------------------------------------------------
        # # Defining particles involved
        MPARENT = lp.mu_minus.mass / u.MeV
        numubar = GenParticle("nu_mu_bar", 0.0)
        nue = GenParticle("nu_e", 0.0)
        positron_0 = GenParticle("e+_0", lp.e_plus.mass / u.MeV)
        electron_1 = GenParticle("e-_1", lp.e_minus.mass / u.MeV)
        positron_1 = GenParticle("e+_1", lp.e_plus.mass / u.MeV)
        electron_2 = GenParticle("e-_2", lp.e_minus.mass / u.MeV)
        positron_2 = GenParticle("e+_2", lp.e_plus.mass / u.MeV)

        if self.channel == "mu1e2nu":
            # ------------------------------------------------------
            # µ -> ν_mu_bar ν_e e+
            # !! Watch out for the ordering of the particles (following diagrams in MadGraph)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                numubar, nue, positron_0
            )
        elif self.channel == "mu3e2nu":
            # ------------------------------------------------------
            # µ -> ν_mu_bar ν_e e+ e+ e-
            # !! Watch out for the ordering of the particles (following diagrams in MadGraph)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                numubar,
                nue,
                positron_0,
                positron_1,
                electron_1,
            )

        elif self.channel == "mu5e2nu":
            # ------------------------------------------------------
            # µ -> ν_mu_bar ν_e e+ e+ e- e+ e-
            # !! Watch out for the ordering of the particles (following diagrams in MadGraph)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(
                numubar,
                nue,
                positron_0,
                positron_1,
                electron_1,
                positron_2,
                electron_2,
            )
        elif self.channel == "mu5e":
            # ------------------------------------------------------
            # µ -> e+ (phi -> (aprime -> e+ e-) (aprime -> e+ e-))
            aprime_1 = GenParticle("dp_1", self.model.maprime).set_children(
                electron_1, positron_1
            )
            aprime_2 = GenParticle("dp_2", self.model.maprime).set_children(
                electron_2, positron_2
            )
            phi = GenParticle("phi", self.model.mphi).set_children(aprime_1, aprime_2)
            self.decay_chain = GenParticle("mu+", MPARENT).set_children(positron_0, phi)

        # ------------------------------------------------------
        # Generate the 4 momenta and weights
        self.w_phasespace, self.wmax, self.particles = self.decay_chain.generate(
            n_events=self.n_events, normalize_weights=False
        )
        self.w_phasespace = self.w_phasespace.numpy()

        # list of daughter particles
        self.daughter_names = list(self.particles.keys())

        # 4-momentum of the parent particle
        # self.p_parent = np.zeros_like(self.particles[self.daughter_names[0]])
        self.p_parent = np.zeros_like(self.particles["e+_0"])
        self.p_parent[:, -1] += MPARENT

        self.put_energy_first()

        self.P_grid = self.build_P_grid()
        self.particle_names = ["mu+"] + list(self.particles.keys())
        self.particles = {}
        for name in self.particle_names:
            self.particles[name] = self.P_grid[:, :, self.particle_names.index(name)]

    def get_track_momenta(self):
        self.tracks = {}

        for name, p in self.particles.items():
            # if electron or positron, then propagate in magnetic field
            if "e+" in name or "e-" in name:
                self.tracks[name] = p
        return self.tracks

    def put_energy_first(self):
        # We need to rearrange the arrays so the first enetry is energy, and not px:
        # `phasespace` indices: 0 -> px, 1 -> py, 2 -> pz, 3 -> E
        # `MadGraph` and `DarkNews` indices: 0 -> E, 1 -> px, 2 -> py, 3 -> pz
        # when rearranging, also convert from TensorFlow object to numpy array
        for k in self.daughter_names:
            self.particles[k] = np.array(self.particles[k])[:, [3, 0, 1, 2]]
        self.p_parent = self.p_parent[:, [3, 0, 1, 2]]

    def build_P_grid(self):
        # dim 0: event number
        # dim 1: lorentz index
        # dim 2: particle number

        # Ordering --> Parent + daughters(following MadGraph convention)
        return np.transpose(
            [self.p_parent] + [self.particles[k] for k in self.daughter_names],
            axes=(1, 2, 0),
        )

    def amp_in_P(self, P):
        if self.amp:
            if self.channel == "mu5e":
                return np.ones(np.shape(P)[0])
            else:
                return self.amp.get_value(P, self.alphaS, self.nhel)

    def evaluate_amplitude(self):
        if self.amp:
            # loops over events and evaluates the amplitude given the list of momenta
            self.w_amp = np.array(
                [
                    self.amp.get_value(self.P_grid[i], self.alphaS, self.nhel)
                    for i in range(self.n_events)
                ]
            )
        else:
            self.w_amp = np.ones((self.n_events,))

        self.weights = (
            self.w_amp
            * self.w_phasespace
            / np.sum(self.w_amp * self.w_phasespace)
            * self.branching
        )

    def place_it_in_Mu3e(self):
        self.pos, self.w_target = fm.get_decay_positions_in_target(self.n_events)
        self.x, self.y, self.z = self.pos.T
        self.weights = (
            self.w_target
            * self.weights
            / np.sum(self.w_target * self.weights)
            * self.branching
        )

        self.n_hits = {name: np.zeros(self.n_events) for name in self.particles.keys()}
        self.n_short_tracks = np.zeros(self.n_events)
        self.n_long_tracks = np.zeros(self.n_events)

        for name, p in self.particles.items():
            # if electron or positron, then propagate in magnetic field
            if "e+" in name or "e-" in name:
                E = p[:, 0]
                pT = np.sqrt(p[:, 1] ** 2 + p[:, 2] ** 2)
                pL = p[:, 3]
                pmag = np.sqrt(pT**2 + pL**2)

                # velocity
                beta_L = pL / E
                beta_T = pT / E

                # Angle wrt the z axis
                theta = np.arccos(pL / pmag)
                angle_lambda = np.pi / 2 - theta

                # xy plane angle
                phi = np.arctan2(p[:, 2], p[:, 1])

                # Radius of the arc trajectory
                arc_R = fm.radius_of_curvature(pT, Bfield=1.0)

                # Time to exit from the detector in z coordinate
                _t_exit = fm.time_of_exit(self.z, beta_L)

                # Maximum arc-angle of the trajectory (>= 2pi if fully recurled)
                _max_arc_angle = np.where(
                    arc_R > 0,
                    _t_exit
                    * np.abs(beta_T)
                    * fm.c_light
                    / (2 * np.pi * arc_R)
                    * 2
                    * np.pi,
                    0,
                )

                # distance from the beam axis at exit point
                _chord_length = np.sqrt(2) * arc_R * np.sqrt(1 - np.cos(_max_arc_angle))
                _max_chord_length = (
                    np.sqrt(2)
                    * arc_R
                    * np.sqrt(1 - np.cos(np.minimum(_max_arc_angle, np.pi)))
                )

                # FIX-ME -- correct this with the appropriate angle between chord and beam-radius.
                _transv_pos_at_exit = _chord_length + fm.r(self.x, self.y)
                _max_transv_pos = _max_chord_length + fm.r(self.x, self.y)

                # Time until the track is recurled
                _t_recurl = fm.time_of_recurl(arc_R, beta_T)
                _z_recurl = _t_recurl * beta_L * fm.c_light

                hit_recurler = (
                    np.abs(_z_recurl) > fm.recurler_L / 2 + fm.outer_recurler_gap
                ) & (
                    np.abs(_z_recurl)
                    < fm.recurler_L / 2 + fm.recurler_L + fm.outer_recurler_gap
                )

                _short_track = _max_transv_pos >= fm.layer4_R
                _long_track = _short_track & (_transv_pos_at_exit < fm.layer4_R)

                # Did it hit the inner cylinder?
                self.n_hits[name][_short_track] += 4

                # Did it hit the outer cylinder?
                self.n_hits[name][_long_track] += 2
                self.n_hits[name] += 2 * (
                    _long_track & (_transv_pos_at_exit < fm.layer2_R)
                )

                self.n_short_tracks += 1 * _short_track
                self.n_long_tracks += 1 * _long_track

        # did it pass selection criteria?
        self.signal_event = self.n_short_tracks == self.n_tracks
        self.particles = fm.smear_samples(self.particles, self.n_hits)
